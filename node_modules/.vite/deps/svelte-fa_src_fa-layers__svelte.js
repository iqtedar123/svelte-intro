import {
  getStyles
} from "./chunk-E6WSLTBZ.js";
import {
  SvelteComponentDev,
  add_location,
  append_styles,
  attr_dev,
  children,
  claim_element,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-XTA3UROE.js";

// node_modules/svelte-fa/src/fa-layers.svelte
var file = "node_modules/svelte-fa/src/fa-layers.svelte";
function add_css(target) {
  append_styles(target, "svelte-66hu08", ".svelte-fa-layers.svelte-66hu08{display:inline-block;position:relative}.svelte-fa-layers.svelte-66hu08 .svelte-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text span{display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEtbGF5ZXJzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtQkEsK0JBQWtCLENBQ2hCLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLFFBQVEsQ0FBRSxRQUNaLENBRUEsK0JBQWlCLENBQVMsVUFBWSxDQUNwQyxRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsQ0FBQyxDQUNULElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLENBQUMsQ0FDUixHQUFHLENBQUUsQ0FBQyxDQUNOLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLE1BQ2QsQ0FFQSwrQkFBaUIsQ0FBUyxzQkFBd0IsQ0FDaEQsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEdBQUcsQ0FDUixJQUFJLENBQUUsR0FBRyxDQUNULFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDakMsQ0FFQSwrQkFBaUIsQ0FBUywyQkFBNkIsQ0FDckQsT0FBTyxDQUFFLFlBQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiZmEtbGF5ZXJzLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let span;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { id: true, class: true, style: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        span,
        "id",
        /*id*/
        ctx[1]
      );
      attr_dev(span, "class", span_class_value = "svelte-fa-layers " + /*clazz*/
      ctx[0] + " svelte-66hu08");
      attr_dev(
        span,
        "style",
        /*s*/
        ctx[2]
      );
      add_location(span, file, 46, 0, 703);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      2) {
        attr_dev(
          span,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*clazz*/
      1 && span_class_value !== (span_class_value = "svelte-fa-layers " + /*clazz*/
      ctx2[0] + " svelte-66hu08")) {
        attr_dev(span, "class", span_class_value);
      }
      if (!current || dirty & /*s*/
      4) {
        attr_dev(
          span,
          "style",
          /*s*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa_layers", slots, ["default"]);
  let { class: clazz = "" } = $$props;
  let { id = "" } = $$props;
  let { style = "" } = $$props;
  let { size = "" } = $$props;
  let { pull = "" } = $$props;
  let s;
  const writable_props = ["class", "id", "style", "size", "pull"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fa_layers> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("pull" in $$props2)
      $$invalidate(5, pull = $$props2.pull);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getStyles,
    clazz,
    id,
    style,
    size,
    pull,
    s
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2)
      $$invalidate(0, clazz = $$props2.clazz);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("pull" in $$props2)
      $$invalidate(5, pull = $$props2.pull);
    if ("s" in $$props2)
      $$invalidate(2, s = $$props2.s);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*style, size, pull*/
    56) {
      $:
        $$invalidate(2, s = getStyles(style, size, pull, true));
    }
  };
  return [clazz, id, s, style, size, pull, $$scope, slots];
}
var Fa_layers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        class: 0,
        id: 1,
        style: 3,
        size: 4,
        pull: 5
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa_layers",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<Fa_layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<Fa_layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_layers_default = Fa_layers;
export {
  fa_layers_default as default
};
//# sourceMappingURL=svelte-fa_src_fa-layers__svelte.js.map
